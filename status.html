<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server Status - Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SF Pro Display Font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">

    <style>
        :root {
            --bauhaus-red: #E53935;
            --bauhaus-blue: #1E88E5;
            --bauhaus-yellow: #FDD835;
            --bauhaus-black: #212121;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff;
            color: var(--bauhaus-black);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 24px;
            padding: 24px;
        }

        .bauhaus-card {
            border: 2px solid var(--bauhaus-black);
            box-shadow: 8px 8px 0 var(--bauhaus-black);
            transition: all 0.2s;
            background: white;
            padding: 24px;
        }

        .bauhaus-card:hover {
            box-shadow: 6px 6px 0 var(--bauhaus-black);
            transform: translate(2px, 2px);
        }

        .bauhaus-btn {
            border: none;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.2s;
            background: var(--bauhaus-yellow);
            color: var(--bauhaus-black);
            padding: 12px 24px;
            border: 2px solid var(--bauhaus-black);
            box-shadow: 4px 4px 0 var(--bauhaus-black);
        }

        .bauhaus-btn:hover {
            transform: translateY(-2px);
            box-shadow: 6px 6px 0 var(--bauhaus-black);
        }

        .bauhaus-input {
            border: 2px solid var(--bauhaus-black);
            font-size: 1rem;
            outline: none;
            padding: 12px;
            width: 100%;
        }

        .bauhaus-input:focus {
            border-color: var(--bauhaus-blue);
        }

        .bauhaus-header {
            font-size: 2.5rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
            margin: 48px 0;
            position: relative;
        }

        .bauhaus-header::after {
            content: '';
            display: block;
            width: 60px;
            height: 6px;
            background: var(--bauhaus-red);
            margin: 24px auto;
        }

        .kv-k {
            font-size: 0.875rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--bauhaus-black);
        }

        .kv-v {
            font-size: 1.125rem;
            font-weight: 500;
            margin-top: 8px;
        }

        .online {
            border-left: 8px solid var(--bauhaus-blue);
        }

        .offline {
            border-left: 8px solid var(--bauhaus-red);
        }

        .bauhaus-circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bauhaus-yellow);
            border: 2px solid var(--bauhaus-black);
        }

        .bauhaus-square {
            width: 24px;
            height: 24px;
            background: var(--bauhaus-blue);
            border: 2px solid var(--bauhaus-black);
        }

        .bauhaus-triangle {
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 24px solid var(--bauhaus-red);
        }

        #trendChart {
            min-height: 300px;
            border: 2px solid var(--bauhaus-black);
            box-shadow: 8px 8px 0 var(--bauhaus-black);
            padding: 24px;
            background: white;
        }

        .modal-content {
            background: white;
            border: 2px solid var(--bauhaus-black);
            box-shadow: 8px 8px 0 var(--bauhaus-black);
            padding: 24px;
        }

        select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 1em;
            padding-right: 48px;
            border: 2px solid var(--bauhaus-black);
        }

        svg.percentage-circle {
            width: 32px;
            height: 32px;
            margin-right: 12px;
        }

        svg.percentage-circle circle {
            transition: stroke-dashoffset 0.35s;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            stroke-width: 10;
        }

        .circle-background {
            stroke: #E5E5E5;
        }

        .circle-progress {
            stroke: var(--bauhaus-blue);
        }

        @media (max-width: 768px) {
            .grid-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <div id="modal-root"></div>

    <!-- React and ReactDOM CDN -->
    <script src="https://cdn.jsdelivr.net/npm/react@17.0.2/umd/react.production.min.js" crossorigin></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@17/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Axios CDN -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const { useState, useEffect, useMemo, useCallback, useReducer, useRef } = React;
        const HOST = '';


        // Helper functions
        const BtoGB = (bytes) => (bytes / 1024 / 1024 / 1024).toFixed(2);
        const usagePercentage = (used, total) => ((used / total) * 100).toFixed(2);
        const formatTime = (timestamp) => new Date(timestamp * 1000).toLocaleTimeString();
        const isOutdated = (timestamp) => Math.floor(Date.now() / 1000) - timestamp > 1 * 60;


        // 定义需要渲染的字段，实际服务器返回的字段中有一些不适合直接展示
        const TITLES = {
            hostname: ['主机名', '', '当前服务器的主机名称'],
            organization: ['组织', '','IP所有者/组织'],
            country: ['国家', '', '服務器所在國家'],
            region: ['地区', '', '服務器所在地區'],
            uptimeDays: ['运行时间', '天', '服务器自上次启动以来的运行天数'],

            tasksInfo: ['进程 (运行中/全部)', '', '当前运行的进程数量与总进程数量'],
            loadAverages: ['负载', '', '系统在过去 1、5、15 分钟的平均负载'],
            memoryUsage: ['内存', '', '当前内存使用情况，已用/可用'],

            trafficInfo: ['总流量 (接收/发送)', 'G', '服务器自上次启动以来的网络总流量，包括接收和发送的数据量'],
            connectionInfo: ['连接数 (TCP/UDP)', '', '当前 TCP 和 UDP 连接数'],
            netTxSpeedKB: ['上传速度', 'K', '当前网络上传速度'],
            netRxSpeedKB: ['下载速度', 'K', '当前网络下载速度'],

            updateAt: ['更新时间', '', '数据最后更新时间'],

            cpu_num_cores: ['CPU 核心数', '', 'CPU 的核心数量'],
            cpu_delay_us: ['CPU 延迟', 'μs', 'CPU 处理任务的延迟时间'],
            cpu_us_percent: ['CPU 用户占用', '%', '用户进程占用的 CPU 百分比'],
            cpu_sy_percent: ['CPU 系统占用', '%', '系统内核占用的 CPU 百分比'],
            cpu_ni_percent: ['CPU 低优先级', '%', '低优先级进程占用的 CPU 百分比'],
            cpu_id_percent: ['CPU 空闲', '%', 'CPU 空闲时间的百分比'],
            cpu_wa_percent: ['CPU IO等待', '%', 'CPU 等待 I/O 操作的时间百分比'],
            cpu_hi_percent: ['CPU 硬件中断', '%', '硬件中断占用的 CPU 百分比'],
            cpu_st_percent: ['CPU 被宿主机占用', '%', '虚拟机被宿主机占用的 CPU 百分比'],

            rootDiskInfo: ['根目录空间', '', '根目录磁盘的使用情况，已用/可用'],
            disk_delay_us: ['磁盘延迟', 'ms', '根目录磁盘 I/O 操作的延迟时间'],
            readsPerSecond: ['读取次数', '', '根目录磁盘采样周期内的读取操作次数'],
            writesPerSecond: ['写入次数', '', '根目录磁盘采样周期内的写入操作次数'],
            avgReadLatency: ['平均读取延迟', 'ms', '根目录磁盘读取操作的平均延迟时间'],
            avgWriteLatency: ['平均写入延迟', 'ms', '根目录磁盘写入操作的平均延迟时间'],
            diskUtilization: ['磁盘利用率', '%', '根目录磁盘的使用率百分比'],
            weightedIoTimePercent: ['加权I/O时间', '%', '根目录磁盘 I/O 操作的加权时间百分比'],
        };


        function PercentageCircle({ percentage }) {
            const radius = 12;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (percentage / 100) * circumference;

            return (
                <svg className="percentage-circle" viewBox="0 0 32 32">
                    <circle
                        className="circle-background"
                        cx="16"
                        cy="16"
                        r={radius}
                        fill="none"
                    />
                    <circle
                        className="circle-progress"
                        cx="16"
                        cy="16"
                        r={radius}
                        fill="none"
                        strokeDasharray={circumference}
                        strokeDashoffset={offset}
                    />
                </svg>
            );
        }


        function calculateAndNormalizeKeys(obj, keys) {
            // 对累计求和占比类字段进行求出分别百分比，例如 CPU 统计信息

            // 1. 计算 keys 列表中所有键的值的总和
            const total = keys.reduce((sum, key) => sum + (obj[key] || 0), 0);

            // 2. 遍历 keys 列表，将每个键的值除以总和，并保留两位小数
            keys.forEach(key => {
                if (obj[key] !== undefined) { // 确保键存在
                    obj[key] = parseFloat(((obj[key] / total) * 100).toFixed(2));
                }
            });

            // 3. 返回处理后的对象
            return obj;
        }


        function calculateUsedMemParcent(obj) {
            // 为统计行添加内存实际使用量和占比字段
            obj.mem_really_used_mib = (obj.mem_total_mib - (obj.mem_free_mib + obj.mem_buff_cache_mib)).toFixed(2);
            obj.mem_used_total_percent = (obj.mem_really_used_mib / obj.mem_total_mib * 100).toFixed(2);
            return obj;
        }

        const TrendModal = ({ clientId, onClose }) => {

            const [apiData, setApiData] = useState(null);
            const [chartData, setChartData] = useState(null);
            const [dataLevel, setDataLevel] = useState('seconds'); // 数据级别：seconds, minutes, hours
            const [selectedKeys, setSelectedKeys] = useState(null); // 选中的 key 列表
            const [availableKeys, setAvailableKeys] = useState([]); // 可选的 key 列表

            // 数据级别选项
            const dataLevelOptions = [
                { value: 'seconds', label: '最近一小时', title: '10秒递进' },
                { value: 'minutes', label: '最近一天', title: '60秒递进' },
                { value: 'hours', label: '最近一年', title: '60分钟递进' },
            ];


            const apiObjectKeys = {
                uptime_s: ["运行时间", "秒", "系统运行的总时间（秒）"],
                load_1min: ["负载-1分钟", "", "过去1分钟的系统平均负载"],
                load_5min: ["负载-5分钟负载", "", "过去5分钟的系统平均负载"],
                load_15min: ["负载-15分钟负载", "", "过去15分钟的系统平均负载"],

                running_tasks: ["任务数-正在进行", "", "当前正在运行的任务数量"],
                total_tasks: ["任务数-全部", "", "系统中总的任务数量"],

                cpu_num_cores: ["CPU-核心数", "", "CPU的核心数量"],
                cpu_delay_us: ["CPU-延迟", "μs", "CPU任务的延迟时间（微秒）"],
                cpu_user: ["CPU-用户占用", "%", "用户空间占用的CPU百分比"],
                cpu_system: ["CPU-系统占用", "%", "内核空间占用的CPU百分比"],
                cpu_nice: ["CPU-低优先级", "%", "低优先级进程占用的CPU百分比"],
                cpu_idle: ["CPU-空闲", "%", "CPU空闲时间的百分比"],
                cpu_iowait: ["CPU-IO等待", "%", "CPU等待IO操作的时间百分比"],
                cpu_irq: ["CPU-硬件中断", "%", "CPU处理硬中断的时间百分比"],
                cpu_softirq: ["CPU-软件中断", "%", "CPU处理软中断的时间百分比"],
                cpu_steal: ["CPU-被宿主机占用", "%", "虚拟CPU等待物理CPU的时间百分比"],

                mem_really_used_mib: ["内存-真实已用", "Mib", "减去缓存和缓冲的内存占用大小（MiB）"],
                mem_used_total_percent: ["内存-已用占比", "%", "真实内存使用量占比"],
                mem_total_mib: ["内存-全部", "MiB", "系统总内存大小（MiB）"],
                mem_free_mib: ["内存-空闲", "MiB", "系统空闲内存大小（MiB）"],
                mem_used_mib: ["内存-已用", "MiB", "系统已用内存大小（MiB）"],
                mem_buff_cache_mib: ["内存-缓存", "MiB", "用于缓存和缓冲的内存大小（MiB）"],

                tcp_connections: ["连接数-TCP", "个", "当前TCP连接数量"],
                udp_connections: ["连接数-UDP", "个", "当前UDP连接数量"],

                default_interface_net_rx_bytes: ["流量-下载速度", "Bit", "当前开机期间默认网络接口接收的总字节数"],
                default_interface_net_tx_bytes: ["流量-上传速度", "Bit", "当前开机期间默认网络接口发送的总字节数"],

                disk_delay_us: ["磁盘-延迟", "ms", "磁盘IO操作的延迟时间（毫秒）"],
                root_disk_total_kb: ["磁盘-根目录总空间", "KB", "根磁盘的总容量（KB）"],
                root_disk_avail_kb: ["磁盘-根目录可用空间", "KB", "根磁盘的可用容量（KB）"],
                reads_completed: ["磁盘-读取完成次数", "", "磁盘读取操作完成的次数"],
                writes_completed: ["磁盘-写入完成次数", "", "磁盘写入操作完成的次数"],
                reading_ms: ["磁盘-读取时间", "ms", "磁盘读取操作的总时间（毫秒）"],
                writing_ms: ["磁盘-写入时间", "ms", "磁盘写入操作的总时间（毫秒）"],
                iotime_ms: ["磁盘-IO时间", "ms", "磁盘IO操作的总时间（毫秒）"],
                ios_in_progress: ["磁盘-进行中的IO操作", "", "当前正在进行的磁盘IO操作数量"],
                weighted_io_time: ["磁盘-加权IO时间", "ms", "加权后的磁盘IO操作时间（毫秒）"],
            };

            // 获取历史数据
            const fetchHistoryData = useCallback(async () => {
                try {
                    const endpoint = `/status/${dataLevel}`; // 根据数据级别选择接口
                    const response = await axios.get(`${HOST}${endpoint}`, {
                        params: { client_id: clientId },
                    });

                    const data = response.data.reverse()
                    // 把CPU相关的8个变量转为百分比表达
                    data.map((item) => calculateAndNormalizeKeys(item, ["cpu_user", "cpu_system", "cpu_nice", "cpu_idle", "cpu_iowait", "cpu_irq", "cpu_softirq", "cpu_steal"]))
                    data.map((item) => calculateUsedMemParcent(item))

                    setApiData(data)

                    if (data && data.length > 0) {
                        // 提取可用的 key 列表（排除 client_id 和 timestamp）
                        const keys = Object.keys(data[0]).filter(
                            (key) => key !== 'client_id' && key !== 'timestamp' && apiObjectKeys.hasOwnProperty(key)
                        );
                        setAvailableKeys(keys); // 设置可选的 key 列表
                        if (!selectedKeys) {
                            setSelectedKeys(['load_1min'])
                        } else {
                            setSelectedKeys(JSON.parse(JSON.stringify(selectedKeys)))
                        }
                    }


                } catch (error) {
                    console.error('Error fetching history data:', error);
                }
            }, [clientId, dataLevel]);

            // 初始化时获取数据
            useEffect(() => {
                console.log('useEffect', 'init')
                fetchHistoryData();
            }, [fetchHistoryData]);

            // 数据级别变化时重新获取数据
            const handleDataLevelChange = (event) => {
                setDataLevel(event.target.value);
            };

            // 选中的 key 变化时更新图表
            const handleSelectedKeysChange = (event) => {
                console.log('selectedKeys', event.target.selectedOptions)
                const selected = Array.from(event.target.selectedOptions, (option) => option.value);
                setSelectedKeys(selected);
            };

            // 选项变化时渲染dom
            useEffect(() => {
                console.log('更新表格数据')
                if (apiData && apiData.length > 0) {


                    function formatTimestamp(timestamp) {
                        const now = Date.now(); // 当前时间戳（毫秒）
                        const targetTime = timestamp; // 将秒级时间戳转换为毫秒
                        const diff = now - targetTime; // 时间差（毫秒）

                        const seconds = (diff / 1000).toFixed(1); // 转换为秒
                        const minutes = (seconds / 60).toFixed(1); // 转换为分钟
                        const hours = (minutes / 60).toFixed(1); // 转换为小时
                        const days = (hours / 24).toFixed(1); // 转换为天

                        if (seconds < 3600) {
                            // 距离现在小于1小时，格式化为 *s
                            return `-${seconds}s`;
                        } else if (hours < 24) {
                            // 距离现在1-24小时，格式化为 *h
                            return `-${hours}h`;
                        } else {
                            // 距离现在超过24小时，格式化为 *d
                            return `-${days}d`;
                        }
                    }

                    // 处理数据，生成 Chart.js 所需的格式
                    const labels = apiData.map((item) => formatTimestamp(item.timestamp * 1000));

                    const CHART_COLORS = {
                        red: 'rgba(255, 99, 132, 0.8)',
                        orange: 'rgba(255, 159, 64, 0.8)',
                        yellow: 'rgba(255, 205, 86, 0.8)',
                        green: 'rgba(75, 192, 192, 0.8)',
                        blue: 'rgba(54, 162, 235, 0.8)',
                        purple: 'rgba(153, 102, 255, 0.8)',
                    };

                    const datasets = selectedKeys.map((key, index) => ({
                        label: key,
                        data: apiData.map((item) => item[key]),
                        borderColor: Object.values(CHART_COLORS)[index % Object.keys(CHART_COLORS).length], // 按顺序分配颜色
                        fill: false,
                        pointStyle: false,
                        borderWidth: 1,
                    }));

                    setChartData({ labels, datasets });
                }
            }, [selectedKeys]);



            // 渲染图表
            useEffect(() => {
                if (chartData) {
                    console.log(chartData, apiObjectKeys[chartData['datasets'][0].label][0])
                    const ctx = document.getElementById('trendChart').getContext('2d');

                    const chart = new Chart(ctx, {
                        type: 'line',
                        data: chartData,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    ticks: {
                                        maxTicksLimit: 5,
                                        autoSkip: true,
                                        font: { size: 10 },
                                    },
                                    grid: { display: false },
                                },
                                y: {
                                    ticks: {
                                        maxTicksLimit: 5,
                                        font: { size: 10 },
                                        callback: (value) => {
                                            const unit = apiObjectKeys[chartData['datasets'][0].label][1]
                                            let tempValue = 0
                                            if (value > 10) {
                                                if (value > 1000) {
                                                    tempValue = Number(value.toFixed(0)).toLocaleString()
                                                }
                                                else {
                                                    tempValue = value.toFixed(0)
                                                }
                                            } else {
                                                tempValue = value.toFixed(2)
                                            }
                                            return `${tempValue}${unit}`
                                        },
                                    },
                                    grid: { display: true, drawBorder: false },
                                },
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: true, mode: 'index', intersect: false },
                            },
                        },
                    });

                    return () => chart.destroy(); // 清理图表实例
                }
            }, [chartData]);

            return React.createElement(
                'div',
                { className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4' },
                React.createElement(
                    'div',
                    { className: 'bg-white rounded-lg p-2 py-4 w-full max-w-4xl' },
                    React.createElement(
                        'div',
                        { className: 'flex justify-between items-center mb-4 ' },
                        React.createElement('h2', { className: 'text-sm font-bold' }, '统计数据'),
                        React.createElement(
                            'button',
                            { onClick: onClose, className: 'text-sm text-gray-500 hover:text-gray-700' },
                            'Close'
                        )
                    ),
                    React.createElement(
                        'div',
                        { className: 'grid grid-cols-2 gap-4 mb-4' },
                        // 数据级别单选框
                        React.createElement(
                            'div',
                            null,
                            React.createElement(
                                'select',
                                {
                                    value: dataLevel,
                                    onChange: handleDataLevelChange,
                                    className: 'text-sm w-full p-2 border rounded',
                                },
                                dataLevelOptions.map((option) =>
                                    React.createElement('option', { key: option.value, value: option.value, title: option.title }, option.label)
                                )
                            )
                        ),
                        // 多选框（数据加载后显示）
                        availableKeys.length > 0 &&
                        React.createElement(
                            'div',
                            null,
                            React.createElement(
                                'select',
                                {
                                    multiple: false,
                                    value: selectedKeys,
                                    onChange: handleSelectedKeysChange,
                                    className: 'text-sm w-full p-2 border rounded',
                                },
                                availableKeys.map((key) =>
                                    React.createElement('option', { key: key, value: key, title: apiObjectKeys[key][2] }, apiObjectKeys[key][0])
                                )
                            )
                        )
                    ),
                    React.createElement(
                        'div',
                        { className: 'relative', style: { minHeight: '350px' } },
                        React.createElement('canvas', { id: 'trendChart' })
                    )
                )
            );
        };





        // Server component
        const ServerCard = ({ data }) => {
            const isOnline = !isOutdated(data.updateAt);
            const cardClasses = `bauhaus-card ${isOnline ? 'online' : 'offline'}`;

            return (
                <div className={cardClasses}>
                    <div className="grid grid-cols-2 gap-4">
                        <div className="col-span-2 flex items-center justify-between">
                            <h3 className="text-xl font-bold uppercase tracking-wider">{data.hostname}</h3>
                            <div className="flex items-center space-x-2">
                                <div className={`bauhaus-circle ${isOnline ? 'bg-bauhaus-blue' : 'bg-bauhaus-red'}`} />
                                <span className="text-sm font-medium">{isOnline ? 'Online' : 'Offline'}</span>
                            </div>
                        </div>
                        {Object.entries(TITLES).map(([key, [title, unit, description]]) => {
                            if (!data[key]) return null;
                            return (
                                <div key={key} className="col-span-1">
                                    <div className="kv-k">{title}</div>
                                    <div className="kv-v">
                                        {typeof data[key] === 'number' ? data[key].toFixed(2) : data[key]}
                                        {unit}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // Reducer for managing expanded states
        const expandedStatesReducer = (state, action) => {
            switch (action.type) {
                case 'TOGGLE':
                    return { ...state, [action.machineId]: !state[action.machineId] };
                default:
                    return state;
            }
        };

        function App() {
            const [servers, setServers] = useState([]);
            const [expandedStates, dispatch] = useReducer(expandedStatesReducer, {});
            const [selectedServer, setSelectedServer] = useState(null);
            const [showModal, setShowModal] = useState(false);
            const [timeRange, setTimeRange] = useState('1h');
            const chartRef = useRef(null);

            useEffect(() => {
                fetchServers();
                const interval = setInterval(fetchServers, 10000);
                return () => clearInterval(interval);
            }, []);

            const fetchServers = async () => {
                try {
                    const response = await axios.get('/status/latest');
                    setServers(response.data);
                } catch (error) {
                    console.error('Error fetching servers:', error);
                }
            };

            const handleServerClick = (server) => {
                setSelectedServer(server);
                setShowModal(true);
            };

            const handleCloseModal = () => {
                setShowModal(false);
                setSelectedServer(null);
            };

            return (
                <div className="min-h-screen bg-white">
                    <header className="bauhaus-header">
                        Server Status Dashboard
                        <div className="flex justify-center space-x-4 mt-4">
                            <div className="bauhaus-circle" />
                            <div className="bauhaus-square" />
                            <div className="bauhaus-triangle" />
                        </div>
                    </header>

                    <div className="grid-container">
                        {servers.map((server) => (
                            <div key={server.machine_id} className="col-span-12 md:col-span-6 lg:col-span-4">
                                <ServerCard data={server} />
                            </div>
                        ))}
                    </div>

                    {showModal && selectedServer && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                            <div className="modal-content w-full max-w-4xl">
                                <div className="flex justify-between items-center mb-6">
                                    <h2 className="text-2xl font-bold uppercase tracking-wider">
                                        {selectedServer.hostname}
                                    </h2>
                                    <button
                                        className="bauhaus-btn"
                                        onClick={handleCloseModal}
                                    >
                                        Close
                                    </button>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div className="col-span-1 md:col-span-2">
                                        <canvas ref={chartRef} id="trendChart" />
                                    </div>
                                    {Object.entries(TITLES).map(([key, [title, unit, description]]) => {
                                        if (!selectedServer[key]) return null;
                                        return (
                                            <div key={key} className="bauhaus-card">
                                                <div className="kv-k">{title}</div>
                                                <div className="kv-v">
                                                    {typeof selectedServer[key] === 'number'
                                                        ? selectedServer[key].toFixed(2)
                                                        : selectedServer[key]}
                                                    {unit}
                                                </div>
                                                <div className="text-sm text-gray-600 mt-2">{description}</div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>

</html>
